<!DOCTYPE html>
<html data-wf-domain="" data-wf-page="56d6955f710a7126338b8b19" data-wf-site="56d6955f710a7126338b8b1c">
  <head>
    <meta charset="utf-8">
    <title>Content Addressing: What Makes IPFS Revolutionary</title>
    <meta content="Permanent Web" name="description">
    <meta content="Understanding IPFS Content Addressing" property="og:title">
    <meta content="" property="og:description">
    <meta property="og:image" content="">
    <meta content="summary" name="twitter:card">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <meta content="Webflow" name="generator"><link href="/blog/style.css" rel="stylesheet" type="text/css">
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js"></script>
    <script type="text/javascript">WebFont.load({
        google: {
        families: ["Open Sans:300,300italic,400,400italic,600,600italic,700,700italic,800,800italic","Lato:100,100italic,300,300italic,400,400italic,700,700italic,900,900italic","Fjalla One:regular"]
        }
      });
    </script>
    <script src="https://daks2k3a4ib2z.cloudfront.net/0globals/modernizr-2.7.1.js" type="text/javascript"></script>
    <link href="/images/fav-icon.png" rel="shortcut icon" type="image/x-icon">
    <link href="https://daks2k3a4ib2z.cloudfront.net/img/webclip.png" rel="apple-touch-icon">
  </head>

  <body>
    <div class="sidebar-column">
      <div class="navigation-bar w-nav" data-animation="default" data-collapse="medium" data-contain="1" data-duration="400">
        <div class="w-container"><a class="logo-link w-nav-brand" href="/"><h1 class="logo-text">RealChain ï ‚Ä¢·¥•‚Ä¢ î</h1></a>
          <nav class="navigation-menu w-nav-menu" role="navigation">
              <p class="main-subheading w-hidden-medium w-hidden-small w-hidden-tiny">
                  Hi there, I‚Äôm Sonia aka realchain ï ‚Ä¢·¥•‚Ä¢ î. I am an independent <b>Bot & Protocol Developer</b>, <b>writer</b> 
                  and <b>speaker</b> from the Africa. I <a href="/blog/archive/">write</a>, <a href="https://twitter.com/realchainlife">tweet</a>, 
                  <a href="/blog/speaking/">speak</a> and <a href="http://github.com/realchainlife">share code</a> about building 
                  decentralized systems. We can <a href="/contact/">work together</a>
              </p>
              <h4>Projects</h4>
              <ul class="[ list-ui  list-ui--small ]  mb">
                <li><a href="http://playmakerchain.com">PlayMaker Chain ‚öΩÔ∏è</a> ‚Äì coming soon‚Ä¶</li>
                <li><a href="http://factory24.org">Afrolynk Factory24 üìà</a> ‚Äì here now ‚Ä¶</li>
                <li><a href="http://realchainlife.github.io/portfolio/workshops.html">Nairobi IPFS</a> ‚Äì Here Now! </li>
              </ul>
              <h4>Upcoming Events</h4>
              <ul class="[ list-ui  list-ui--small ]  mb">
                <li><a href="https://africanwomenintech.com/">AWIT Conference</a> ‚Äì Nairobi, (Kenya) July 2019</li>
                <li><a href="http://afrolynk.com">Afrolynk Conference</a> ‚Äì Berlin, (Germany) September 2019</li>
              </ul>
              <div class="divider"></div>
              <div class="social-link-group">
                <a class="social-icon-link w-inline-block" href="https://twitter.com/realchainlife"><img src="http://uploads.webflow.com/56d6955f710a7126338b8b1c/56d6955f710a7126338b8b95_social-18-white.svg" width="25"></a>
                <a class="social-icon-link w-inline-block" href="https://github.com/realchainlife"><img src="http://uploads.webflow.com/56d6955f710a7126338b8b1c/56d6955f710a7126338b8b9f_social-33-white.svg" width="25"></a>
              </div>
            </nav>
          <div class="menu-button w-nav-button"><div class="w-icon-nav-menu"></div>
        </div>
      </div>
    </div>
  </div>
  <div class="content">
    <div class="w-container">
      <div class="post-title-section">
        <h1>Content Addressing: What Makes IPFS Revolutionary</h1>
        <div class="post-info-wrapper">
          <div class="post-info">August 12, 2018</div>
          <div class="post-info">|</div>
          <a class="post-info when-link" href="/categories/ipfs">IPFS</a>
        </div>
      </div>
      <div class="body-copy w-richtext">
        <p>IPFS is an internet protocol that makes the web faster, safer, and distributed. It
          changes the addressing of information, moving from location addressing to content 
          addressing. It provides cryptographic hash content addressing, file integrity and 
          versioning, filesystem-level encryption and signing support by combining a series 
          of old and new technologies.
        </p>
        <p>Before diving into how content addressing on the IPFS works, lets briefly explore some
          feature components that set IPFS apart from other internet Protocols like HTTP:
        </p>
        <ol>
          <li><strong>Network</strong> - The IPFS network runs by combining more protocols 
            that make the connectivity integrity more reliable and authentic. These include 
            the transport protocols, data-channels, using uTP or SCTP, using HMAC with sender‚Äôs 
            public key, etc.
          </li>
          <li><strong>Objects</strong> - IPFS builds a Merkle DAG, a directed acyclic graph 
            which providesIPFS many useful properties like content addressing, tamper resistance 
            and deduplication.
          </li>
          <li><strong>Files</strong>- On top of the Merkle DAG, IPFS defines a set of objects 
            for modeling a versioned filesystem . This object models include  block, list, tree 
            & commit.
          </li>
          <li><strong>Naming</strong> - IPNS is the DNS for IPFS. IPNS assigns every user a 
            mutable namespace at: /ipns/<NodeId></NodeId> where a user can publish 
            an Object to this path signed by their private keys. 
          </li>
        </ol>
        <p>All the components of the IPFS can be covered in separate articles but in this post 
          we‚Äôll explore how node <em>identifiers, routing</em> and <em>data disrtibution</em> works. 
          We will also look into `content addressing`, to find out exactly what happens when you 
          add a file to IPFS.
        </p>
        <h2>Identity, Routing, and Data Distribution</h2>
        <p><strong>Node identification</strong> follows the scheme from S/Kademlia where nodes are 
          identified by a `NodeId`, the cryptographic hash of a public-key, created with S/Kademlia‚Äôs 
          static crypto puzzle. Nodes store their public and private keys (encrypted with a passphrase). 
          Basically:
        </p>
        <ul>
          <li>Nodes in this peer to peer network each hold private keys and release public keys, 
            just like in Bitcoin or Ethereum.
          </li>
          <li>Node addresses are derived through hashing their public keys. Allowing connection 
            verification through message signing.
          </li>
          <li>Their public keys can be used to encrypt data before it is transferred, preventing 
            interception and theft.
          </li>
        </ul>
        <p>Users are free to instatiate a ‚Äúnew‚Äù node identity on every launch, though that loses 
          accrued network benefits. <strong>Nodes are incentivized to remain the same</strong>. The 
          crypto-puzzle is a proof-of-work scheme that makes it hard for an attacker to quickly create 
          lots of identities (<em>a Sybil attack</em>).
        </p>
        <p>Solutions to the security issues of today‚Äôs web are built into this addressing system. 
          There is no need for a trusted central certificate issuer to provide connection verification 
          tools and all connections can easily be encrypted by default. No more SSL.
        </p>
        <p>For <strong>Routing</strong>> IPFS uses a Distributed Sloppy Hash Table (DSHT). DHT is a 
          distributed system that provides access to the key-value store. The store is spread across 
          the participating nodes and offers excellent performance and scalability.
        </p>
        <figure data-rt-type="image" data-rt-align="center" data-rt-max-width="60" class="w-richtext-align-center" 
          style="max-width: 60%;" data-rt-max-height="33.75">
          <div><img src="/blog/blog-img/distributed-hash-table.png" alt=""></div>
          <figcaption>Illustration: Distributed Hash Table</figcaption>
        </figure>
        <p>The DHT part of the IPFS comes from Kademlia DHT as used in BitTorrent while the ‚Äúsloppy‚Äù 
          in DSHT part comes from the Coral DSHT which relaxes the DHT API from <i>get_value(key)</i> to 
          <i>get_any_values(key)</i> and can work with single peer. In return, Coral can distribute only 
          subsets of the values to the ‚Äúnearest‚Äù nodes, avoiding node hot-spots.
        </p>
        <p><strong>Data distribution,</strong> on the other hand, is based on a variant of BitTorrent called 
          <em>BitSwap</em>. Incentives are designed in to encourage nodes to store blocks for others, and to 
          prevent freeloaders. The strategy used in BitSwap to exchange information with peers is pluggable. 
          The choice of function should aim to:
        </p>
        <ol>
            <li>maximize the trade performance for the node, and the whole exchange</li>
            <li>prevent freeloaders from exploiting and degrading the exchange</li>
            <li>be effective with, and resistant to other, unknown, strategies</li>
            <li>be lenient to trusted peers</li>
        </ol>
        <p>In order to have something to barter with, a node that has nothing its peers want then seeks 
          the pieces that its peers want, with lower priority than it seeks its own blocks. ‚ÄúThis 
          incentivizes nodes to cache and disseminate rare pieces, even if they are not interested 
          in them directly.‚Äù
        </p>
        <p>The Bitswap protocol also encourages fair play by incentivizing nodes to seed even when they 
          do not need anything in particular, as they might have the blocks others want. Thus, BitSwap 
          nodes send blocks to their peers optimistically, expecting the debt to be repaid. It prevents
          freeloading by implementing a simple credit-like system that solves the problem by making:
        </p>
        <ol>
            <li>Peers track their balance (in bytes verified) with other nodes. </li>
            <li>Peers send blocks to debtor peers probabilistically, according to a function that
                falls as debt increases.</li>
        </ol>
        <p>The credit system is backed up by the BitSwap nodes that keep ledgers accounting the transfers 
          with other nodes. This allows nodes to keep track of history and avoid tampering. When activating 
          a connection, BitSwap nodes exchange their ledger information. If it does not match exactly, the 
          ledger is reinitialized from scratch, losing the accrued credit or debt.
        </p>
        <h2>Content Addressing and Paths</h2>
        <p>Content addressing is a technique to reference files or data by a unique <em>fingerprint</em> 
          derived from the contents of the file or data itself. Content addressing is implemented 
          with cryptographic hashing, so that content addresses are secure, permanent, and derived 
          directly from the content itself. 
        </p>
        <p>IPFS uses content addressing to ensure files, websites, and webapps can move around the 
          network and be distributed by any computer securely and with perfect fidelity. All content, 
          including links, is uniquely identified by its multihash checksum. Paths in IPFS are of 
          the format:
        </p>
        <pre><span style="">ipfs/hash-of-object/name-path-to-object</span></pre>
        <p>IPFS is designed to allow the files of millions of users to coexist together. The DHT, 
          with content-hash addressing ensures fair and secure publication of objects. Nodes can 
          pin objects to the IPFS making them available for all peers on the network. In the process
          of adding and publishing objects, they run through a hash function to produce a digest. The
          hash produced is guaranteed to be cryptographically uniue to the contents of the object.
        </p>
        <p>Note that Objects are essentially immutable, just like in Git. New versions hash differently, 
          and thus are new objects. Basically, if the content of the file change by even one bit, the 
          hash is also changed. Tracking versions is the job of additional versioning objects. This 
          object hashing process is best illustrated in the image below, the object in this case, a
          cat photo.
        </p>
        <figure data-rt-type="image" data-rt-align="center" data-rt-max-width="60" class="w-richtext-align-center" 
          style="max-width: 60%;" data-rt-max-height="33.75">
          <div><img src="/blog/blog-img/content-hashing.png" alt=""></div>
          <figcaption>Illustration: IPFS Content Hashing, Source: Textile</figcaption>
        </figure>
        <p>Currently, on the web, if a file is moved, all links to that file need to be updated if they 
          are to resolve. Because IPFS addresses are derived from the content they refer to, if the 
          content still exists anywhere on the network, links will always resolve. This removes any need 
          for duplication of content, except for the purposes of greater persistence security or for 
          scaling up serving capabilities.
        </p>
        <h3>Implications of Content Address</h3>
        <p>Now that we understand how content addressing works, what are the implication for the web as
          we know it? We know that hash links permanently point to exact content and from a computer 
          science perspective, any time we create data that uses content-addressed links, a persistent 
          and permanent data structure is created. Some of the implications of storing and sharing data 
          this way include:
        </p>
        <ul>
          <li><strong>Data is Never Lost</strong> - Unlike centralized servers that lose data in the 
            event of server failures or other limitations this decentralized, content-addressed ensures 
            that data will not become endangered as long as a valid copy of it exists on the IPFS peer 
            network.
          </li>
          <li><strong>Data Integrity is Maintained</strong> - Content-addressing enables us to check the 
            data's fingerprints against the links because the connections are resilient and reliable even 
            on a large scale. This kind of validation is impossible with location-addressed links.
          </li>
          <li><strong>Links Don't Die</strong> - IPFS links permanently point to their content. In the 
            unlikely event that entire copies of objects are destroyed, once a node re-publishes the content 
            all the network peers can continue to link to cryptographic hash of the object or content.
          </li>
          <li><Strong>No Single Point of Failure</Strong> - As long as at least one node on the network has 
            a copy of the content, it will permanently remain available. Although content can be served from 
            different nodes, it is cryptographically verified to ensure its not tampered with and users access 
            the files as originally published.
          </li>
        </ul>
        <p>There are alot more ways content-addressing will change the way we use the web, however, for 
          a decentralized storage system to grow to replace the current model, we need more ways to 
          incentivize the storage and serving of content in this way. One such way is changing the way we
          link to content - IPFS accomplishes this using a special feature called `IPNS`.
        </p>
        <h2>Mutable References and Human-readable names</h2>
        <p>IPNS, the **Interplanetary Naming System** is the DNS of IPFS. To truly appreciate the 
          genius of IPNS, lets first explore the how content can be retrived from the IPFS. You'll
          need the hash of the object. Using the example of the cat photo above, we'll access the 
          file at `https://ipfs.io/ipfs/QmcBsE7VjTVZKYDmkzzw3A1FVXsBb5hUqJ5BqT34Xp27m`
        </p>
        <p>To do this, we use a private key to sign a reference to the IPFS hash representing the 
          latest version of our file using its public key hash. But this approach has several 
          challenges:
        </p>
        <ul>
          <li>Firstly, it‚Äôs hard to read, let alone remember.</li>
          <li>Secondly, it‚Äôs an immutable link. Which means its permanent. Any changes to the 
            content would generate a new pubkey hash which would break the link to the file.
          </li>
        </ul>
        <p>The IPNS addresses these problems by creating human readable mutable links and by pointing 
          to the pubkey hash to the latest version of any object.
        </p>
        <h3>Human-Readable Mutable Addressing</h3>
        <p>IPNS allows you to use the existing Domain Name System (DNS) to provide human-readable 
          links to IPFS/IPNS content. It does this by allowing you to insert the hash into a TXT 
          record on your nameserver. The name, which follows `/ipns/` in a link is the hash of a 
          public key. It is forever associated with the hash it links to that is signed by the 
          corresponding private key.
        </p>
        <p>Simply put, IPNS is a global namespace based on <a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">Public Key Infrastructure</a> 
          (or PKI) which allows us to build encrypted and authenticated trust chains. IPFS has plans 
          to also support Namecoin, which could be used to create a completely decentralized, distributed 
          web that has no requirements for a central authority in the entire chain. No ICANN, no central 
          servers, no politics, no expensive certificate "authorities", and no choke points.
        </p>
        <h3>How we'll use IPFS/IPNS in the future</h3>
        <p>Long-term, the IPFS can be used for storing all of our sites, and issue IPNS keys for each 
          site. Users will continue to publish content on the IPFS and link other users independently.
          This will effectively remove user dependency on centralized servers permanently changing the
          way we use the web today. If you ask me, this is revolutionary technology whose transforming
          I'm excitedly watching for.
        </p>
      </div>
      <div class="button-wrapper"><a class="button w-button" href="/blog/archive">‚Üê&nbsp;View all posts</a></div>
    </div>
  </div>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript"></script>
  <script src="https://daks2k3a4ib2z.cloudfront.net/56d6955f710a7126338b8b1c/js/webflow.3283bff92.js" type="text/javascript"></script>
<!--[if lte IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/placeholders/3.0.2/placeholders.min.js"></script><![endif]-->
</body>
</html>

